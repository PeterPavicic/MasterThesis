import os
import re
import itertools
import requests
from enum import EnumDict, StrEnum
from datetime import datetime

# Subgraphs
class SG(StrEnum):
# ORDERS_SG = "https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/polymarket-orderbook-resync/prod/gn"
    ORDERS_SG = "https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/orderbook-subgraph/0.0.1/gn"
    POSITIONS_SG = "https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/positions-subgraph/0.0.7/gn"
    ACTIVITY_SG = "https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/activity-subgraph/0.0.4/gn"
    OPEN_INTEREST_SG = "https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/oi-subgraph/0.0.6/gn"
    PNL_SG = "https://api.goldsky.com/api/public/project_cl6mb8i9h0003e201j6li0diw/subgraphs/pnl-subgraph/0.0.14/gn"


# TODO: Also implement duplicates here, maybe in separate classses?

# Define Enum where we specify each type of query & the corresponding
# queryName, and variables returned by the query
class SQ(EnumDict):
    # from OrderBook subgraph
    MarketData = {
        "name": "marketDatas",
        "returnVariables": [
            "id",
            "condition",
            "outcomeIndex"
        ]
    }
    """
    Information about the market 
    Input: Filtering
    Returns: id, condition, outcomeIndex
    """

    OrdersFilled = {
        "name": "orderFilledEvents",
        "returnVariables": [
            "transactionHash",
            "timestamp",
            "orderHash",
            "maker",
            "taker",
            "makerAssetId",
            "takerAssetId",
            "makerAmountFilled",
            "takerAmountFilled",
            "fee"
        ]
    }
    """
    Exchange OrderFilled event stored directly (transactions)
    Input: Filtering
    Returns: transactionHash, timestamp, orderHash, maker, taker, makerAssetId, takerAssetId, makerAmountFilled, takerAmountFilled, fee
    """

    OrdersMatched = {
        "name": "ordersMatchedEvents",
        "returnVariables": [
            "id",
            "timestamp",
            "makerAssetID",
            "takerAssetID",
            "makerAmountFilled",
            "takerAmountFilled"
        ]
    }
    """
    Exchange OrdersMatched event stored directly
    Input: Filtering
    Returns: id, timestamp, makerAssetID, takerAssetID, makerAmountFilled, takerAmountFilled
    """

    OrderBook = {
        "name": "orderbooks",
        "returnVariables": [
            "id",
            "tradesQuantity",
            "buysQuantity",
            "sellsQuantity",
            "collateralVolume",
            "scaledCollateralVolume",
            "collateralBuyVolume",
            "scaledCollateralBuyVolume",
            "collateralSellVolume",
            "scaledCollateralSellVolume"
        ]
    }
    """
    Aggregate order book info for 1 asset id
    Input: ERC1155 TokenID
    Returns: id, tradesQuantity, buysQuantity, sellsQuantity, collateralVolume, scaledCollateralVolume, collateralBuyVolume, scaledCollateralBuyVolume, collateralSellVolume, scaledCollateralSellVolume
    """

    OrdersMatchedGlobal = {
        "name": "ordersMatchedGlobals",
        "returnVariables": [
            "tradesQuantity",
            "buysQuantity",
            "sellsQuantity",
            "collateralVolume",
            "scaledCollateralVolume",
            "collateralBuyVolume",
            "scaledCollateralBuyVolume",
            "collateralSellVolume",
            "scaledCollateralSellVolume"
        ]
    }
    """
    Exchange - all trades aggregated
    Input: Filtering
    Returns: tradesQuantity, buysQuantity, sellsQuantity, collateralVolume, scaledCollateralVolume, collateralBuyVolume, scaledCollateralBuyVolume, collateralSellVolume, scaledCollateralSellVolume
    """

    # from Positions subgraph
    UserBalances = {
        "name": "userBalances",
        "returnVariables": [
            "id",
            "user",
            "asset",
            "balance"
        ]
    }
    """
    User Balances in each asset ever traded
    Input: Filtering
    Returns: id, user, asset, balance
    """

    NetUserBalances = {
        "name": "netUserBalances",
        "returnVariables": [
            "id",
            "user",
            "asset",
            "balance"
        ]
    }
    """
    Net User Balances in each asset ever traded
    Input: Filtering
    Returns: id, user, asset, balance
    """

    TokenIdConditions = {
        "name": "TokenIdConditions",
        "returnVariables": [
            "id",
            "condition",
            "complement",
            "outcomeIndex"
        ]
    }
    """
    Data about ERC1155 token
    Input: Filtering
    Returns: id, condition, complement, outcomeIndex
    """

    Conditions = {
        "name": "conditions",
        "returnVariables": [
            "id",
            "payouts"
        ]
    }
    """
    Conditions for ERC1155 token
    Input: Filtering
    Returns: id, payouts
    """

    # from Activity subgraph
    Split = {
        "name": "splits",
        "returnVariables": [
            "id",
            "timestamp",
            "stakeholder",
            "condition",
            "amount"
        ]
    }
    """
    Information about splits
    Input: Filtering
    Returns: id, timestamp, stakeholder, condition, amount
    """

    Merge = {
        "name": "merges",
        "returnVariables": [
            "id",
            "timestamp",
            "stakeholder",
            "condition",
            "amount"
        ]
    }
    """
    Information about merges
    Input: Filtering
    Returns: id, timestamp, stakeholder, condition, amount
    """

    Redemption = {
        "name": "redemptions",
        "returnVariables": [
            "id",
            "timestamp",
            "redeemer",
            "condition",
            "indexSets",
            "payout"
        ]
    }
    """
    Information about redemptions 
    Input: Filtering
    Returns: id, timestamp, redeemer, condition, indexSets, payout
    """

    NegRiskConversion = {
        "name": "negRiskConversions",
        "returnVariables": [
            "id",
            "timestamp",
            "stakeholder",
            "negRiskMarketId",
            "amount",
            "indexSet",
            "questionCount"
        ]
    }
    """
    Information about events of NegRisk conversion
    Input: Filtering
    Returns: id, timestamp, stakeholder, negRiskMarketId, amount, indexSet, questionCount
    """

    NegRiskEvents = {
        "name": "NegRiskEvents",
        "returnVariables": [
            "id",
            "condition",
            "outcomeIndex"
        ]
    }
    """
    Markets where NegRisk can happen and question count
    Input: Filtering
    Returns: id, condition, outcomeIndex
    """

    Fpmms = {
        "name": "fixedProductMarketMakers",
        "returnVariables": [
            "id"
        ]
    }
    """
    FPMM'text IDs
    Input: Filtering
    Returns: id
    """

    Position = {
        "name": "positions",
        "returnVariables": [
            "id",
            "condition",
            "outcomeIndex"
        ]
    }
    """
    Metadata for the market, by ERC1155 token IDs
    Input: Filtering
    Returns: id, condition, outcomeIndex
    """

    Condition = {
        "name": "conditions",
        "returnVariables": [
            "id"
        ]
    }
    """
    Condition IDs
    Input: Filtering
    Returns: id
    """

    # from Open Interest subgraph
    # Conditions
    # NegRiskEvents
    MarketOpenInterest = {
        "name": "marketOpenInterests",
        "returnVariables": [
            "id",
            "amount"
        ]
    }
    """
    Open interest amount for market
    Input: Filtering
    Returns: id, amount
    """

    GlobalOpenInterest = {
        "name": "globalOpenInterest",
        "returnVariables": [
            "id",
            "amount"
        ]
    }
    """
    Open interest on all of Polymarket
    Input: Filtering
    Returns: id, amount
    """

    # from P&L subgraph
    UserPosition = {
        "name": "UserPositions",
        "returnVariables": [
            "id",
            "user",
            "tokenId",
            "amount",
            "avgPrice",
            "realizedPnl",
            "totalBought"
        ]
    }
    """
    Users' active ERC1155 token positions
    Input: Filtering
    Returns: id, user, tokenId, amount, avgPrice, realizedPnl, totalBought
    """


# Class for subqueries, which are the payload of the queries sent to the API
class Subquery:
    """
    Creates subqueries which are building blocks of queries
    """

    def __init__(self, subqueryType: SQ, filterText: str | None = None, startPage: int = 0):
        self.SQType = subqueryType
        self.Filter = filterText
        self.StartPage = startPage
        self.__buildSubQuery()


    def __buildSubQuery(self) -> None:
        text = f"""
    {self.SQType["name"]} (
        skip: VAR_SKIP
        first: VAR_FIRST
        orderBy: timestamp
        orderDirection: asc"""

        if self.Filter is not None:
            text += f"""
        where: {{
            {self.Filter}
        }}"""

        text += f"""
    ) {{
        {"\n".join(self.SQType["returnVariables"])}
    }}"""
        self.QueryText = text


    def __str__(self) -> str:
        return(self.QueryText)


class Query:
    """
    Query which is comprised of subqueries which are all sent to GoldSky API
    """

    def __init__(self, operationName: str, endPoint: SG, subqueries: list[Subquery] | Subquery):
        # XOR(subqeries is not None, customQuery is not None)
        self.Name = operationName
        self.APILink = endPoint

        if isinstance(subqueries, Subquery):
            self.Subqueries = [subqueries]
        else:
            self.Subqueries = subqueries

        self.__buildQuery()


    # Builds query from subqueries
    def __buildQuery(self) -> None:
        subqueryCount = len(self.Subqueries)

        # Create query arguments, a.k.a. skip and first variables
        paginationVariables = [f"$skip{i}: Int, $first{i}: Int" for i in range(subqueryCount)]
        queryArguments = f"({", ".join(paginationVariables)})"

        # Builds full query text from subqueries, with given operation name
        text = f"""
query {self.Name} {queryArguments} {{
    {"\n".join([subquery.QueryText for subquery in self.Subqueries])}
}}
        """

        # Replace each VAR_SKIP and VAR_FIRST with corresponding $skip and $first values
        counter = itertools.count(0)
        re.sub(r"VAR_SKIP", lambda _: f"$skip{next(counter)}", text)
        re.sub(r"VAR_FIRST", lambda _: f"$first{next(counter)}", text)

        self.QueryText = text
        

    def run_query(self):

        # WARNING: Code assumes it is being run from root directory of project
        TEMP_OUTPUT_DIR_START = "../Data Transactions/"
        TIMEOUT = 100
        PAGESIZE = 1000

        # Get queryNames from subqueries
        queryNames = [sq.SQType["name"] for sq in self.Subqueries]
        startPages = [sq.StartPage for sq in self.Subqueries]

        output_dirs = [os.path.join(TEMP_OUTPUT_DIR_START, qn) for qn in queryNames]

        for od in output_dirs:
            os.makedirs(od, exist_ok=True)

        while True:
            if len(self.Subqueries) == 0:
                    break

            # Add variables used to pagination
            subqueryCount = len(self.Subqueries)
            paginationVariables = {}
            for i in range(subqueryCount):
                paginationVariables[f"skip{i}"] = startPages[i]
                paginationVariables[f"first{i}"] = PAGESIZE

            # Prepare request payload
            payload = {
                "query": self.QueryText,
                "operationName": self.Name,
                "variables": paginationVariables
            }

            try:
                response = requests.post(self.APILink, json=payload, timeout=TIMEOUT)
                response.raise_for_status()
                data = response.json()
            except requests.RequestException as e:
                print(f"[variables={paginationVariables}] [time={datetime.now()}] Network/HTTP error: {e}")
                break
            except json.JSONDecodeError:
                print(f"[variables={paginationVariables}] [time={datetime.now()}] Failed to parse JSON response.")
                break

            if "errors" in data:
                print(f"[skip={skip}] [time={datetime.now()}] GraphQL errors:", data["errors"])
                break

            

    

    def add_query(self, subquery):
        assert self.Subqueries is not None
        self.Subqueries.append(subquery)

    def rebuildQuery(self):
        self.queryText = self.__buildQuery()

    def __str__(self):
        return self.queryText


QUERY_TEMPLATE_MAKER = """
query TrumpWinsElectionMarket($skip: Int!, $first: Int!) {
    orderFilledEvents(
        skip: $skip,
        first: $first,
        orderBy: timestamp,
        orderDirection: asc,
        where: {
        makerAssetId_in: [
        "21742633143463906290569050155826241533067272736897614950488156847949938836455",
        "48331043336612883890938759509493159234755048973500640148014422747788308965732"
        ]
    }
        ) {
        transactionHash
        orderHash
        timestamp
        makerAssetId
        takerAssetId
        maker {
            id
        }
        taker {
            id
        }
        makerAmountFilled
        takerAmountFilled
        fee
    }
}
"""

QUERY_TEMPLATE_TAKER = """
query TrumpWinsElectionMarket($skip: Int!, $first: Int!) {
    orderFilledEvents(
        skip: $skip,
        first: $first,
        orderBy: timestamp,
        orderDirection: asc,
        where: {
        takerAssetId_in: [
        "21742633143463906290569050155826241533067272736897614950488156847949938836455",
        "48331043336612883890938759509493159234755048973500640148014422747788308965732"
        ]
    }
        ) {
        transactionHash
        orderHash
        timestamp
        makerAssetId
        takerAssetId
        maker {
            id
        }
        taker {
            id
        }
        makerAmountFilled
        takerAmountFilled
        fee
    }
}
"""

QUERY_TEMPLATE_MATCHED_MAKER = """
query findTrumpMatchedOrders($skip: Int!, $first: Int!) {
    ordersMatchedEvents (
        skip: $skip,
        first: $first,
        orderBy: timestamp
        orderDirection: asc
        where:{
        makerAssetID_in: [
        "21742633143463906290569050155826241533067272736897614950488156847949938836455",
        "48331043336612883890938759509493159234755048973500640148014422747788308965732"
        ]
    }
        )
    {
        id    
        timestamp
        makerAssetID
        takerAssetID
        makerAmountFilled
        takerAmountFilled
    }
}
"""

QUERY_TEMPLATE_MATCHED_TAKER = """
query TrumpWinsMatchedOrders ($skip: Int!, $first: Int!) {
    ordersMatchedEvents (
        skip: $skip,
        first: $first,
        orderBy: timestamp,
        orderDirection: asc,
        where: {
        takerAssetId_in: [
        21742633143463906290569050155826241533067272736897614950488156847949938836455,
        48331043336612883890938759509493159234755048973500640148014422747788308965732
        ]
    }
        ) {
        id    
        timestamp
        makerAssetID
        takerAssetID
        makerAmountFilled
        takerAmountFilled
    }
}
"""
